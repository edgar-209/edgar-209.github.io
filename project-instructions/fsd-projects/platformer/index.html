<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HalleBot's Platformer Adventure</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game container and canvas */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        #gameCanvas {
            border: 5px solid #3b82f6; /* Blue border for the game */
            background-color: #e5e7eb; /* Light grey game background */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            max-width: 1200px;
            width: 100%;
            display: block;
        }
        /* Style for the game HUD/controls */
        .game-info {
            background-color: #374151;
            color: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="flex flex-col items-center w-full max-w-4xl">
        <div class="game-info w-full text-center">
            <h1 class="text-2xl font-bold mb-1 text-blue-300">HalleBot's Challenge: Extreme Mode</h1>
            <p class="text-sm">Use <span class="font-mono bg-gray-600 px-1 rounded">A / D</span> or <span class="font-mono bg-gray-600 px-1 rounded">‚Üê / ‚Üí</span> to move, <span class="font-mono bg-gray-600 px-1 rounded">SPACE</span> to jump.</p>
            <div id="status-message" class="text-yellow-400 font-semibold mt-2">Collect all 5 items!</div>
        </div>

        <canvas id="gameCanvas" width="1200" height="600"></canvas>
    </div>

    <script>
        // --- GAME FRAMEWORK SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Global Game Constants
        const GRAVITY = 0.5;
        const JUMP_STRENGTH = -15;
        const MAX_VELOCITY = 8;
        const TILE_SIZE = 100;
        const CANNON_PROJECTILE_SPEED = 10;
        const MAX_WIDTH = canvas.width;
        const MAX_HEIGHT = canvas.height;
        // Respawn point constants
        const START_X = 50;
        const START_Y = MAX_HEIGHT - 50;

        // Game State and Entities
        let gameActive = true;
        let score = 0;
        let player = {
            x: START_X,
            y: START_Y,
            width: 30,
            height: 40,
            color: '#ef4444', // Red
            vx: 0,
            vy: 0,
            onGround: false,
        };

        const entities = {
            platforms: [],
            collectables: [],
            cannons: [],
            projectiles: []
        };

        const keys = {
            left: false,
            right: false,
            up: false,
            space: false
        };

        // --- CORE ENTITY CREATION FUNCTIONS ---

        /**
         * @param {number} x
         * @param {number} y
         * @param {number} width
         * @param {number} height
         * @param {string} [color='grey']
         */
        function createPlatform(x, y, width, height, color = '#6b7280') {
            entities.platforms.push({ x, y, width, height, color });
        }

        /**
         * @param {string} type
         * @param {number} x
         * @param {number} y
         * @param {number} [gravity=0]
         * @param {number} [bounce=0]
         */
        function createCollectable(type, x, y, gravity = 0, bounce = 0) {
            entities.collectables.push({
                type, x, y, gravity, bounce,
                width: 25, height: 25, collected: false, vy: 0, onGround: false
            });
        }

        /**
         * @param {string} side - "top", "bottom", "left", or "right"
         * @param {number} position - distance from top (for left/right) or left (for top/bottom)
         * @param {number} delay - time in ms between shots
         */
        function createCannon(side, position, delay) {
            entities.cannons.push({ side, position, delay, lastShot: Date.now() });
        }

        function createProjectile(x, y, vx, vy) {
            entities.projectiles.push({
                x, y, vx, vy,
                radius: 8, color: '#1f2937', // Dark projectile
                ttl: 300 // time to live frames
            });
        }

        /**
         * Enables a grid overlay for easy coordinate placement
         */
        function toggleGrid() {
            // This function is for development purposes only.
        }
        
        // Function to handle player respawn
        function respawnPlayer() {
            // Reset position to starting point
            player.x = START_X;
            player.y = START_Y;
            // Reset movement
            player.vx = 0;
            player.vy = 0;
            player.onGround = true;
            player.color = '#ef4444'; // Reset player color to Red
            document.getElementById('status-message').innerHTML = `‚ö†Ô∏è Respawn! Collect ${collectableTypes.length - score} items.`;

            // Clear all active projectiles for a brief moment of safety
            entities.projectiles.length = 0;

            // Ensure the game is active (in case the previous hit paused it)
            gameActive = true;
        }

        // --- INPUT HANDLING ---
        document.addEventListener('keydown', (e) => {
            if (!gameActive) return;
            switch (e.key) {
                case 'a':
                case 'ArrowLeft':
                    keys.left = true;
                    break;
                case 'd':
                case 'ArrowRight':
                    keys.right = true;
                    break;
                case ' ':
                    keys.space = true;
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.key) {
                case 'a':
                case 'ArrowLeft':
                    keys.left = false;
                    break;
                case 'd':
                case 'ArrowRight':
                    keys.right = false;
                    break;
                case ' ':
                    keys.space = false;
                    break;
            }
        });

        // --- LEVEL DESIGN IMPLEMENTATION (EXTREME Difficulty) ---

        // Platforms (The layout remains the same as the previous "Hard Mode")
        createPlatform(0, MAX_HEIGHT - 20, MAX_WIDTH, 20, '#10b981'); // The main floor (Green)
        createPlatform(150, 500, 100, 20, '#3b82f6'); // Platform 1
        createPlatform(450, 420, 80, 20, '#3b82f6'); // Platform 2
        createPlatform(700, 350, 150, 20, '#3b82f6'); // Platform 3
        createPlatform(MAX_WIDTH - 20, 200, 20, MAX_HEIGHT - 220, '#3b82f6'); // Platform 4 (Wall)
        createPlatform(850, 200, 50, 20, '#3b82f6'); // Platform 5 (Tricky)
        createPlatform(0, 150, 200, 20, '#3b82f6'); // Platform 6 (Destination)
        createPlatform(50, 280, 60, 20, '#3b82f6'); // Platform 7 (High jump)


        // UPDATED: Add 5 Collectables
        const collectableTypes = ["diamond", "grace", "max", "code", "star"];

        // Collectable 1: Easy-to-get start item
        createCollectable(collectableTypes[0], 225, 460);

        // Collectable 2: Requires navigating the central islands
        createCollectable(collectableTypes[1], 770, 310);

        // Collectable 3: Requires reaching the very small high-up platform
        createCollectable(collectableTypes[2], 860, 160);
        
        // NEW Collectable 4: Near Platform 7 (Requires careful jump and dodge)
        createCollectable(collectableTypes[3], 80, 240); 

        // NEW Collectable 5: On the top-left destination platform
        createCollectable(collectableTypes[4], 100, 110);


        // UPDATED: Add 6 Cannons (Faster firing and more coverage)

        // Cannon 1: Left side, targeting the starting jump path (medium speed)
        createCannon("left", 480, 1500); 

        // Cannon 2: Top side, targeting the central floating island (fast)
        createCannon("top", 500, 1000); 

        // Cannon 3: Right side, protecting the third collectable (very fast)
        createCannon("right", 100, 800); 

        // NEW Cannon 4: Bottom side, firing up towards the gap between platform 2 and 3 (fast)
        createCannon("bottom", 600, 950);

        // NEW Cannon 5: Left side, targeting the lower route/gap near platform 7 (medium fast)
        createCannon("left", 300, 1200);

        // NEW Cannon 6: Top side, targeting the approach to the tricky platform 5 (very fast)
        createCannon("top", 800, 750);


        // --- GAME LOGIC AND PHYSICS ---

        function updatePlayer() {
            if (!gameActive) return;

            // Horizontal movement
            let dx = 0;
            if (keys.left) dx -= 1;
            if (keys.right) dx += 1;

            if (dx !== 0) {
                player.vx += dx * 1.5;
                player.vx = Math.max(-MAX_VELOCITY, Math.min(MAX_VELOCITY, player.vx));
            } else {
                player.vx *= 0.8; // Deceleration
            }

            // Jump
            if (keys.space && player.onGround) {
                player.vy = JUMP_STRENGTH;
                player.onGround = false;
                keys.space = false; // Prevent holding jump
            }

            // Apply gravity
            player.vy += GRAVITY;

            // Apply velocity to position (X-axis)
            player.x += player.vx;
            // X-axis collision with world bounds
            if (player.x < 0) {
                player.x = 0;
                player.vx = 0;
            } else if (player.x + player.width > MAX_WIDTH) {
                player.x = MAX_WIDTH - player.width;
                player.vx = 0;
            }

            // Apply velocity to position (Y-axis)
            player.y += player.vy;
            player.onGround = false;

            // Check if player falls off the bottom of the map (respawn)
            if (player.y > MAX_HEIGHT) {
                respawnPlayer();
                return; // Stop update for this frame
            }

            // Y-axis collision with platforms
            for (const p of entities.platforms) {
                if (
                    player.x < p.x + p.width &&
                    player.x + player.width > p.x &&
                    player.y + player.height > p.y &&
                    player.y + player.height - player.vy <= p.y // Check if falling onto platform
                ) {
                    player.y = p.y - player.height;
                    player.vy = 0;
                    player.onGround = true;
                }
            }
            
            // Y-axis collision with world floor (safety check against MAX_HEIGHT boundary)
            if (player.y + player.height > MAX_HEIGHT) {
                player.y = MAX_HEIGHT - player.height;
                player.vy = 0;
                player.onGround = true;
            }
        }

        function updateCollectables() {
            entities.collectables = entities.collectables.filter(c => {
                if (c.collected) return false;

                // Player collision check
                if (
                    player.x < c.x + c.width &&
                    player.x + player.width > c.x &&
                    player.y < c.y + c.height &&
                    player.y + player.height > c.y
                ) {
                    score++;
                    document.getElementById('status-message').innerHTML = `‚úÖ Collected! Score: ${score} / ${collectableTypes.length}`;
                    if (score === collectableTypes.length) {
                        gameActive = false;
                        document.getElementById('status-message').innerHTML = 'üéâ You Win! All collectables gathered!';
                        player.color = '#10b981'; // Turn player green on win
                    }
                    return false; // Remove collectable
                }

                // Apply gravity and physics if defined
                if (c.gravity > 0) {
                    c.vy += c.gravity;
                    c.y += c.vy;

                    // Platform collision for bouncy collectables
                    for (const p of entities.platforms) {
                        if (
                            c.x < p.x + p.width && c.x + c.width > p.x &&
                            c.y + c.height > p.y && c.y + c.height - c.vy <= p.y
                        ) {
                            c.y = p.y - c.height;
                            c.vy *= -c.bounce;
                            c.onGround = true;
                        }
                    }
                }

                return true;
            });
        }

        function updateCannons() {
            const now = Date.now();
            for (const cannon of entities.cannons) {
                if (now - cannon.lastShot > cannon.delay) {
                    let x, y, vx = 0, vy = 0;
                    const size = 10; // Cannon size offset

                    switch (cannon.side) {
                        case 'left':
                            x = 0; y = cannon.position;
                            vx = CANNON_PROJECTILE_SPEED;
                            break;
                        case 'right':
                            x = MAX_WIDTH; y = cannon.position;
                            vx = -CANNON_PROJECTILE_SPEED;
                            break;
                        case 'top':
                            x = cannon.position; y = 0;
                            vy = CANNON_PROJECTILE_SPEED;
                            break;
                        case 'bottom':
                            x = cannon.position; y = MAX_HEIGHT;
                            vy = -CANNON_PROJECTILE_SPEED;
                            break;
                    }
                    createProjectile(x + (vx < 0 ? -size : 0), y + (vy < 0 ? -size : 0), vx, vy);
                    cannon.lastShot = now;
                }
            }

            // Update projectiles
            entities.projectiles = entities.projectiles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.ttl--;

                // Player collision check (Respawn)
                if (
                    p.x + p.radius > player.x && p.x - p.radius < player.x + player.width &&
                    p.y + p.radius > player.y && p.y - p.radius < player.y + player.height
                ) {
                    respawnPlayer();
                    return false; // Remove projectile
                }

                // Check world bounds or TTL
                return p.ttl > 0 &&
                       p.x > -p.radius && p.x < MAX_WIDTH + p.radius &&
                       p.y > -p.radius && p.y < MAX_HEIGHT + p.radius;
            });
        }

        // --- DRAWING FUNCTIONS ---

        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 1;
            for (let x = TILE_SIZE; x < MAX_WIDTH; x += TILE_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, MAX_HEIGHT);
                ctx.stroke();
            }
            for (let y = TILE_SIZE; y < MAX_HEIGHT; y += TILE_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(MAX_WIDTH, y);
                ctx.stroke();
            }
        }

        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            // Simple visual indicator for HalleBot's eyes/sensors
            ctx.fillStyle = '#fef08a';
            ctx.fillRect(player.x + 5, player.y + 5, 5, 5);
            ctx.fillRect(player.x + player.width - 10, player.y + 5, 5, 5);
        }

        function drawPlatforms() {
            for (const p of entities.platforms) {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.width, p.height);
            }
        }

        function drawCollectables() {
            for (const c of entities.collectables) {
                const text = c.type.toUpperCase().substring(0, 2);
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#f59e0b'; // Gold-like color
                ctx.fillText(text, c.x + c.width / 2, c.y + c.height / 2);
                ctx.strokeStyle = '#92400e';
                ctx.strokeRect(c.x, c.y, c.width, c.height);
            }
        }

        function drawCannons() {
            ctx.fillStyle = '#4b5563'; // Dark grey cannons
            for (const c of entities.cannons) {
                let x, y, width, height;
                const barrelLength = 15;
                const cannonSize = 25;

                switch (c.side) {
                    case 'left':
                        x = 0; y = c.position - cannonSize / 2;
                        width = cannonSize; height = cannonSize;
                        ctx.fillRect(x + width, y + height/4, barrelLength, height/2); // Barrel
                        break;
                    case 'right':
                        x = MAX_WIDTH - cannonSize; y = c.position - cannonSize / 2;
                        width = cannonSize; height = cannonSize;
                        ctx.fillRect(x - barrelLength, y + height/4, barrelLength, height/2); // Barrel
                        break;
                    case 'top':
                        x = c.position - cannonSize / 2; y = 0;
                        width = cannonSize; height = cannonSize;
                        ctx.fillRect(x + width/4, y + height, width/2, barrelLength); // Barrel
                        break;
                    case 'bottom':
                        x = c.position - cannonSize / 2; y = MAX_HEIGHT - cannonSize;
                        width = cannonSize; height = cannonSize;
                        ctx.fillRect(x + width/4, y - barrelLength, width/2, barrelLength); // Barrel
                        break;
                }
                ctx.fillRect(x, y, width, height); // Cannon base
            }

            // Draw projectiles
            ctx.fillStyle = '#1f2937';
            for (const p of entities.projectiles) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- MAIN GAME LOOP ---
        function gameLoop() {
            // Clear the canvas
            ctx.clearRect(0, 0, MAX_WIDTH, MAX_HEIGHT);

            // Redraw grid if enabled (assuming a global flag for simplicity)
            // if (gridEnabled) { drawGrid(); }

            // Update logic
            updatePlayer();
            updateCollectables();
            updateCannons();

            // Drawing logic
            drawPlatforms();
            drawCollectables();
            drawCannons();
            drawPlayer();

            // Loop
            requestAnimationFrame(gameLoop);
        }

        // Initialize the game
        window.onload = function() {
            // Simple check to determine if the grid should be drawn for TODO 1
            const gridEnabled = false; // Set to true to see the grid
            if (gridEnabled) {
                // If you uncomment the line below in a real environment, the grid will appear.
                // toggleGrid = drawGrid;
                // For this complete example, we'll draw it once if the flag is true.
                drawGrid();
            }

            // Start the game loop
            gameLoop();
        };

    </script>
</body>
</html>